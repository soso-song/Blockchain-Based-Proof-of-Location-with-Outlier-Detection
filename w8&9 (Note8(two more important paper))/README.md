# W8~9 Target:

1. Check more Peer to Peer paper
1. Check Proocessing Method (PC->PoL):
   - Parameter:
     - All PC
     - max bluetooth range
     - possible move speed
     - for each node
       - reputation score
       - each Betwneess
       - last PoL trust score
   - Return
     - location/range/time
     - new PoL with trust score

## 08_CLIP_Continuous_Location_Integrity_and_Provenance_for_Mobile_Phones(Cited15)

> CLIP aims at providing the integrity of users’ mobility traces.
>
> Each node record all history sensor data (like signal strength for stationary user/witnesses)
>
> Sounds like Paper_02 Blockchain-based Proof of Location (Peer to Peer)
> Referenced as an infrastructure-independent approach by paper02 Blockchain-based Proof of Location.

<img src="/Users/soso/Desktop/Research/w8&9/Note8.assets/image-20230309185405374.png" alt="image-20230309185405374" style="zoom:150%;" />

##### Summary:

1. User(Prover) want to prove their location -> send request to Verifier
   - by internet

2. Verifier then contacts nearby Witness (AP or Peers) (distributed architecture)

   - Witnesses create SLPs based on their own sensor data and send to Verifier
     - SLP includes info about Witness's location and time

3. The Verifier collects all of the SLPs from nearby Witnesses and 

   - use SLPs to verify the Prover's presence at specific location points. 

     - checks each SLP matches up with mobility trace
     - involves comparing the information in each SLP with other sensor data collected by Wireless Access Points (APs) and other sources

     - "leverages existing resources, such as public road maps, available wireless APs or co-located mobile devices, for continuous location veriﬁcation."

   - checks with CA to check all parties involved are authorized and have valid digital certificates using Internet.

4. Return results to Prover (Presence Claim)

##### Request

Verifier (such as a government agency or a private company, that has the authority to verify the user's location) receive and check if mobility trace and SLPs of User (prover) are match up.

- mobility trace
  - generated by sensors already built into smartphones, like GPS, accelerometer, and magnetometer
  - sequence of past location points at corresponding time points
  - stored on the user's smartphone
  - send to verifier
- SLPs: Secure Location Proof (special codes)
  - witness generates the SLPs based on the user's location at a certain time
    - witness is a nearby mobile user or stationary wireless access point (AP) that agrees to create a Secure Location Proof (SLP) when they receive the prover's request.
  - stored by the user on their smartphone
  - send to verifier

##### Return

Prover receives the verification message contains a digital signature that is generated by the verifier's private key, which can be verified using the verifier's public key

## 13_Toward Privacy Preserving and Collusion Resistance in a Location Proof Updating System(Cited126)

>Cited by 02,08,12 mentioned APPLAUS
>
>APPLAUS: A Privacy-Preserving LocAtion proof Updating System
>
>- Bluetooth devices mutually generate location proofs and send updates to a location proof server.

Key Points

- **Periodically changed pseudonyms** are used by the mobile devices to protect source location privacy from each other, and from the untrusted location proof server.
  - Public key + Random String for every request (Pervent relay attacks)
- **User-centric location privacy model** in which individual users evaluate their location privacy levels and decide whether and when to accept the location proof requests.
  - High Privacy -> Ask less witnesses nearby
    - Based on this evaluation, the requesting device decides whether or not to accept a location proof exchange request from another device.

- Against Colluding Attacks
  - Approaches for outlier detection
    - Betweenness ranking-based:
      - Importance: the algorithm looks at how many times that pseudonym appears on the shortest path between any two other pseudonyms in the graph
      - Then rank all of the pseudonyms based on their importance value
      - Low importance ranking node is suspicious nodes
    - Correlation clustering-based:
      - Make a temporal-weighted graph which grouping similar location proofs together based on their time delay, if two proofs are received within a short time frame of each other, they might be grouped together because they are likely to be from the same user.
      - Once all of the similar location proofs have been grouped together, suspicious location proofs are identified as those that do not fit well into any of these groups
  - **Poisson distribution**
    - In this scheme, the prover periodically sends out a location proof request to its neighboring devices through Bluetooth.
    - Authors chose to use Poisson distribution as a way to control the rate at which location proofs are updated. By using this method, they can make it harder for people to figure out where you are by looking at the updates. 

When a new node (such as a person's phone or other device) wants to join the network, it must go through the following steps: 

1. Generate a set of M public/private key pairs: The new node generates a set of M public/private key pairs, where M is a predetermined number. 
2. Register with the Certificate Authority (CA): The new node registers with the online CA by sending its public keys to the CA. The CA then associates these public keys with the real identity of the new node in its database.
3. Preload public/private key pairs: The new node preloads its set of M public/private key pairs before entering the network.
4. Broadcast location proof requests: When the new node needs to collect location proofs from its neighboring nodes, it broadcasts a location proof request through Bluetooth.
5. Once a neighboring node agrees to provide location proof for the new node, this node becomes a witness of the new node. The witness generates a location proof and sends it back to the new node.
6. Verify location proofs: The server verifies that the location proofs provided by witnesses are consistent with each other and that they match up with what is expected based on other information collected from nearby nodes.
7. Overall, these steps allow for secure and private joining of mobile nodes into the network while also enabling them to collect and verify location proofs when necessary.



# Paper

### Problem Definition

##### Want to Slove: 

> Decentralized and infrastructure-independent proof-of-location scheme using short-range communication technologies such as Bluetooth

##### Problem Analysis:

> The different PoL schemes may have a different flow, but generally, we could break them into several parts:

1. New Node joins the network

2. Generates a "Presence Claim."

   - A node sends a request.

   - Other nodes generate.

3. Verify the Presence Claim


##### Presence Claim vs PoL:



##### Available Tools:

1. Prove of Coverage
   - Inspired by the Guided Tour Protocol 
   - **envelope** of envelopes: Use **network connection** to help validate Bluetooth connection.

2. Secret Network:

   - We dont need granularity level from paper05, paper08

3. Connection:

   > Paper02: We consider an LBS-oriented peer-to-peer network with mobile nodes that are connected to the Internet through the WiFi or cellular network interface, and are able to exchange information with neighboring nodes through short-range communication technologies such as Bluetooth

   - Combination of Short-range Communication Technologies
     - Bluetooth/Wifi/NFC/QR code
   - Long-range Communication that communicates with blockchain.

##### Magic Variables to Solve the Problem:

- **Infrastructure-independent** vs Infrastructure-dependent

- Allow disconnected graph

- Aggregation/reputation system?

- The minimum number of nodes involved when generating a presence claim

  - Small

    - the schema will have low security
    - At least 2 to communicate with the network (user & node)

  - Large

    - the schema will have low scalability, giving the network a higher chance of not being available.

  - Dynamic

    > How to get large numbers while keeping scalability

    - Contracting multiple stages for the project using decentralized governance(improvement proposal) or a hardcoded timer:

    - FOAM's example (paper04):

      > FOAM using the infrastructure-dependent approach, a set of Zone Anchors are assumed to be available to produce proofs of the location to users.

      Stage 1: provides Token Curated Registries(TCR), which record the Points of Interest(POI) the community maintains. When the number of POI reaches a number, the project enters stage

      > They designed a native protocol token that incentivizes the marketplace between consumers(want to utilize the list), candidates(want to be on the list), and token holders.
      >
      > Notice we are not a project whitepaper. This part shows how protocol design could push the project through the stage. 
      
      Stage 2: The TCR accumulates enough information in a decentralized manner, so the FOAM can provide PoL services with a high minimum number of nodes involved (1 user + 4 anchors) when generating a presence claim.

- The number of roles that can be played

  - User + subset of {Prover, Verifiers, Anchor, Authority, ....}

- Retroactive vs Proactive location proof (paper05)

  - A retroactive location proof: collect location proofs when aksed (user check-in at the conference)
    - (PoL with SN) (support "around" using PC history)

  - A proactive location proof: collect location proofs continuously (notify user conference nearby)
    - (PC)



### Proposed Configurations

#### Configuration 0:

> Decision that seems reasonable for now

##### Properties:

1. Infrastructure-independent
2. Not allow disconnected graph (allow PC but PoL limited)
3. Aggregation/reputation system: need
   - option1: compute during PoL
   - option2: node have a reputation
4. Communication:
   - Short-range with neighbors:
     - Communicate with all reachable nodes to get as much data as possible for the network.
   - Long-range with blockchain: 
     - accept or request tasks that implicitly cause role change for some "random" node on the network.
5. Minimum number of neighbors: 1 
   - maybe Min number of Betweenness more useful
6. States of a Node:
   - User/Witness PC=(User,Witness)
   - Challenger (Envelope of Envelopes or Multi-Layer Data Packet)
     - requesting PoL
     - Could be Application vs Random node
   - Target (Envelope of Envelopes)
   - ~~Verifier/Application/Router~~ (not a node)
7. Proactive location proof: collect PC continuously

#### Configuration 2:

> This configuration focuses on **proactive location proof**. 
>
> The network takes regular snapshots of every 'neighbor pair,' which are added to the list S along with the time they were taken. 
>
> Network nodes are also occupied with processing the oldest snapshots in S. This processing involves removing/adding the 'neighbor pair' using all available information (utilizing game theory/machine learning/Pokemon Go's cheating detection).
>
> The processing method could be improved by adding a improvement proposal.
>
> New users are required to participate in several snapshots before being able to provide a usable PoL in the archived snapshots.
>
> The PoL only contains information about the user's trajectory, which may not be suitable for most real-time games.

This configuration supports an aggregation/reputation system, which means that the PoL approach can utilize all the information available in the network (depending on the processing method). Logically, this makes it the most secure PoL approach.

Replace snapshot with PC

Paper mention few possible processing method.



#### Test Cases:

1. Wormhole attack
   - Short-range communication technology hardware is capable of doing long-range.
2. Sybil attacks and Collusion attacks
3. Replay attack
4. Cheating on own geographic location



#### Privacy:

> The classic blockchain trilemma (Security/Decentralization/Speed) is insufficient when describing the web3 applications. I define the application tetralemma (Security/Decentralization/Speed+Privacy), which is more suitable to most recent web3 projects like Secret Network.

Nodes have complete control over the time and target they want to expose their Presence Claim. Secret Network powers this flexibility and privacy.



